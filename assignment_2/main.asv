%% First we generate input data
birthdate =  20010930;  % Write the birth date on format yyyymmdd for oldest member in the group
format compact
[lambdavec,Tvec,cvec] = deal([0.0531,0.0430,0.0474,0.0554,0.0269,0.0503,0.0672,0.0352,0.0170],[6,9,15,29,14,21,39,9,12],[13,15,22,22,11,54,83,35,24]); %getSPOdata(birthdate)   %yyyymmdd  Do not use clear command or change the values of these variables

% -------------------------------------------------------------------------------------------------------------------
%% Marginal Allocation
% Question 1 should be answered in the report

% Question 2 should described in the report, and submitted below
% Enter on the format EBO2 = [EBO_1(2) EBO_2(2) ... EBO_9(2)]      
% EBO_j(2) should be the EBO for two spares of LRU2
% Cost2 should be the total cost for the allocation of spares (scalar) 

EBO2 = lambdavec.*Tvec - R_vec(lambdavec,Tvec,zeros(1,9)) - R_vec(lambdavec,Tvec,ones(1,9));
Cost2 = sum(cvec*2);

Q2 = [EBO2 Cost2]; % Checking both at the same time in grader.

% Question 3, you should describe how the Marginal allocation is
% implemented in your own words in the report, and compute all efficient
% points.

s = zeros(9);

%%
s_vec = zeros(1,9);
s_mat = zeros(1,9);
EBOs_mat = lambdavec.*Tvec;
EBOs_vec = [sum(lambdavec.*Tvec)];
counter = 1;

while dot(cvec,s_vec) < 500
    counter = counter+1;
    disp(EBOs(counter-1,:))
    
    quot = R_vec(lambdavec,Tvec,s_vec)./cvec;
    [maxVal, argMax] = max(quot);
    s_vec(argMax) = s_vec(argMax)+1;

    if dot(cvec,s_vec) > 500
        s_vec(argMax) = s_vec(argMax)-1;
        break
    end
    increase_s = zeros(1,9)
    increase_s(argMax) = s_vec(a)

    EBOs_mat(counter,argMax) = EBOs_mat(counter-1,argMax)-R_vec(lambdavec,Tvec,s_vec(argMax));
    EBOs_vec(counter) = sum(EBOs_vec(counter-1) - R_vec(lambdavec,Tvec,s_vec));

    s_mat = [s_mat;s_vec];
end
plot(EBOs_vec)


% Question 4 should be answered in the report, with a figure and a table with
% all efficient points
% Furthermore, a table with first five efficient points should be submitted below
 
% Enter on the format EPtable = [ x0 EBO(x0) C(x0); x1 EB0(x1) C(x1); ... x4 EBO(x4) C(x4)]
% Where xj is the row vector with number of spare parts of each kind
% corresponding to the efficient points generated by the Marginal allocation algorithm
% EBO and C are the total values (scalars) for each allocation xj
EPtable = "to do"

% Question 5 should be discussed in the report

% You may use the commands below as a template to plot the figures.
% fig1 = figure(1)
% plot(total_cost,EBO_expect,'.-k','LineWidth',2,'MarkerSize',20)
% hold on   % Keeps old plots and adds new plots on top of the old
% hold off  % Replaces old plots with the new one
% grid on
% set(gca,'FontSize',20,'TickLabelInterpreter','latex')
% xlabel("Total Cost [-]",'FontSize',20,'interpreter','latex')
% ylabel("EBO [-]",'FontSize',20,'interpreter','latex')
% title('Efficient Solutions Curve','FontSize',20,'interpreter','latex')
% print(fig1, '-dpdf', 'myfigure.pdf'); % save to the 'myfigure.pdf' file

% -------------------------------------------------------------------------------------------------------------------
%% Dynamic Programming
% Question 6 should be answered in the report

% Question 7 should be answered in the report, and submitted below
% as a row vector with numbers of LRU1 used for budget 0 to 50.
LRU1 = "to do"

% Question 8 should be answered in the report, and submitted below
% Enter on the format DynPtable = [ x0 EBO(x0) C(x0); x1 EB0(x1) C(x1); ... x4 EBO(x4) C(x4)]
% Where x0 to x4 are the row vectors with number of spare parts of each kind
% corresponding to the points optimal for budgets 0,100,150, 350, 500.
DynPtable = "to do"

% Question 9 should be answered in the report

% Question 10 should be answered in the report, and submitted below
NumberOfConfigurations = "to do"

%% functions

function r_vec = R_vec(lambdavec,Tvec,s_vec)
    l = lambdavec.*Tvec;

    prob_sum = zeros(1,9);
    for j =1:9
        for i = 0:s_vec(j)
            prob_sum(j) = prob_sum(j) + (l(j).^i).*exp(-l(j))/factorial(i);
        end
    end
    r_vec = 1 - prob_sum;
end

